%!PS-Adobe-3.0
%%Title: Classify.hs, Func.hs, Train.hs, runkFold.hs, test.hs
%%For: Bertil Nilsson
%%Creator: a2ps version 4.14
%%CreationDate: Tue Oct  4 08:12:10 2011
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Portrait
%%Pages: 8
%%PageOrder: Ascend
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontType get 0 eq {
    currentfont /FontMatrix get 3 get
  }{
    currentfont /FontMatrix get 3 get 1000 mul
  } ifelse
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% composite fonts for ASCII-EUC mixed strings
% Version 1.2 1/31/1990
% Original Ken'ichi HANDA (handa@etl.go.jp)
% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
% Anyone can freely copy, modify, distribute this program.

/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
	1 index maxlength add dict begin
	{	1 index /FID ne 2 index /UniqueID ne and
		{def} {pop pop} ifelse
	} forall
	currentdict
	end
} bind def

/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
    /RomanRotation exch def
    /RomanOffset exch def
    /RomanScale exch def
    userdict /fixeucfont_dict known not {
	userdict begin
	    /fixeucfont_dict 2 dict begin
		/UpperByteEncoding [
		    16#00 1 16#20 { pop 0 } for
		    16#21 1 16#28 { 16#20 sub } for
		    16#29 1 16#2F { pop 0 } for
		    16#30 1 16#74 { 16#27 sub } for
		    16#75 1 16#FF { pop 0 } for
		] def
	        /LowerByteEncoding [
		    16#00 1 16#A0 { pop /.notdef } for
		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
				    (cXX) dup 1 4 -1 roll
				    putinterval cvn } for
		    /.notdef
		] def
		currentdict
	    end def
	end
    } if
    findfont dup /FontType get 0 eq {
	14 dict begin
	    %
	    % 7+8 bit EUC font
	    %
	    12 dict begin
		/EUCFont exch def
		/FontInfo (7+8 bit EUC font) readonly def
		/PaintType 0 def
		/FontType 0 def
		/FontMatrix matrix def
		% /FontName
		/Encoding fixeucfont_dict /UpperByteEncoding get def
		/FMapType 2 def
		EUCFont /WMode known
		{ EUCFont /WMode get /WMode exch def }
		{ /WMode 0 def } ifelse
		/FDepVector [
		    EUCFont /FDepVector get 0 get
		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
		    {
			13 dict begin
			    /EUCFont EUCFont def
			    /UpperByte exch 16#80 add def	
			    % /FontName
			    /FontInfo (EUC lower byte font) readonly def
			    /PaintType 0 def
			    /FontType 3 def
			    /FontMatrix matrix def
			    /FontBBox {0 0 0 0} def
			    /Encoding
				fixeucfont_dict /LowerByteEncoding get def
			    % /UniqueID
			    % /WMode
			    /BuildChar {
				gsave
				exch dup /EUCFont get setfont
				/UpperByte get
				2 string
				dup 0 4 -1 roll put
				dup 1 4 -1 roll put
				dup stringwidth setcharwidth
				0 0 moveto show
				grestore
			    } bind def
			    currentdict
			end
			/lowerbytefont exch definefont
		    } forall
		] def
		currentdict
	    end
	    /eucfont exch definefont
	    exch
	    findfont 1 copyfont dup begin
		RomanRotation {
			/FontMatrix FontMatrix
			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
			matrix concatmatrix def
		}{
			/FontMatrix FontMatrix
			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
			def
			/CDevProc
			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
		} ifelse
	    end
	    /asciifont exch definefont
	    exch
	    /FDepVector [ 4 2 roll ] def
	    /FontType 0 def
	    /WMode 0 def
	    /FMapType 4 def
	    /FontMatrix matrix def
	    /Encoding [0 1] def
	    /FontBBox {0 0 0 0} def
%	    /FontHeight 1.0 def % XXXX
	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
	    /Descent -0.3 def   % XXXX
	    currentdict
	end
	/tmpfont exch definefont
	pop
	/tmpfont findfont
    }{
	pop findfont 0 copyfont
    } ifelse
} def	

/slantfont {	% FontName slant-degree  slantfont  font'
    exch findfont 1 copyfont begin
    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
    /FontMatrix exch def
    currentdict
    end
} def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 842 def
/sw 595 def
/llx 24 def
/urx 571 def
/ury 818 def
/lly 24 def
/#copies 1 def
/th 20.000000 def
/fnfs 15 def
/bfs 7.509610 def
/cw 4.505766 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 121.400000 mul
def
/ph
   748.708135 th add
def
/pmw 0 def
/pmh 0 def
/v 0 def
/x [
  0
] def
/y [
  pmh ph add 0 mul ph add
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1) 1
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(-----------------------------------------------------------------------------) c n
(--) N
(-- Module      :  Main) N
(-- Copyright   :) N
(-- License     :  AllRightsReserved) N
(--) N
(-- Maintainer  :) N
(-- Stability   :) N
(-- Portability :) N
(--) N
(-- |) N
(--) N
(-----------------------------------------------------------------------------) N
() p n
(module) K
( Main \() p n
() N
(    main) N
() N
(\) ) S
(where) K n
() p n
(import) K
( System.Environment \(getArgs\)) p n
(import) K
( Data.List \(\)) p n
(import) K
( System.Exit \(exitSuccess, exitFailure\)) p n
(import) K
( GHC.IO.IOMode \(IOMode\(..\)\)) p n
(import) K
( Func) p n
(       \(Image,readImages, Face,step,percieveFace, rotImgCorrect\)) N
(import) K
( Control.Monad \(zipWithM_\)) p n
() N
(-- | main tries to classify the images in the file given as the first paramater and output the) c n
(--   correct face as 1,2,3 or 4.) N
(--   If no file is specified it exits with an error. This program is run with already trained weights) N
(--   saved in the project root. The files loaded are "eye-weights" and "mouth-weights".) N
() p n
(main = ) S
(do) K n
(    args <- getArgs) p n
(    ) S
(if) K
( null args) p n
(       ) S
(then) K
( ) p
(do) K
( putStrLn ") p
(No arguments given, exiting) str
(") p n
(               exitFailure) N
(       ) S
(else) K
( ) p
(do) K n
() p n
(    inputContents <- readFile $ head args) N
(    dirtyEyeW <- readFile ") S
(/home/id09/id09bnn/edu/5DV121/eye-weights) str
(") p n
(    dirtyMouthW <- readFile ") S
(/home/id09/id09bnn/edu/5DV121/mouth-weights) str
(") p n
(    ) S
(let) K
( images = map \(rotImgCorrect 20\) $ readImages inputContents) p n
(        eyew = read dirtyEyeW ) S
(::) K
( ) p
([) K
(Double) p
(]) K n
(        mouthw = read dirtyMouthW ) p
(::) K
( ) p
([) K
(Double) p
(]) K n
(        answers = classify eyew mouthw images) p n
(        output = zip answers ) S
([) K
(1..) p
(]) K n
(    ) p
(-- Format the output and map putStrLn over the output.) c n
(    mapM_ \(\\\(ans, num\) ) p
(->) K
( putStrLn $ ") p
(Image) str
(" ++ \(show num\) ++ ") p
( ) str
(" ++ \(show ans\)\) output) p n
(    exitSuccess) N
() N
() N
(classify :: [Double] -> [Double] -> [[Double]] -> [Int]) C n
(classify eyew mouthw images = map \(percieveFace eyew mouthw step\) images) p n
() N
() N
(Classify.hs) (Page 1/1) (Oct 04, 11 8:02) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (1/8) (Tuesday October 04, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 2
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(-----------------------------------------------------------------------------) c n
(--) N
(-- Module      :  Func) N
(-- Copyright   :) N
(-- License     :  AllRightsReserved) N
(--) N
(-- Maintainer  :) N
(-- Stability   :) N
(-- Portability :) N
(--) N
(-- |) N
(--) N
(-----------------------------------------------------------------------------) N
() p n
(module) K
( Func \() p n
() N
(    chunks,) N
(    getEyesMouth,) N
(    getFace,) N
(    Face,) N
(    Image,) N
(    train,) N
(    numCorrect,) N
(    test,) N
(    percieve,) N
(    percieveFace,) N
(    step,) N
(    writePGM,) N
(    shuffle,) N
(    rotImgCorrect,) N
(    readImages,) N
(    readAnswers,) N
(    kFold) N
() N
(\) ) S
(where) K n
() p n
() N
(import) K
( System.Random \(randomRIO\)) p n
(import) K
( Data.Array.IO) p n
(import) K
( Data.List \(sortBy, intersperse\)) p n
(import) K
( Control.Monad) p n
(import) K
( Debug.Trace \(trace\)) p n
(import) K
( Data.Char \(isAlpha\)) p n
() N
(type) K
( Image = ) p
([) K
(Double) p
(]) K n
(type) S
( Weight = Double) p n
(type) K
( Face = Int     ) p
(-- 1 = Happy, 2 = Sad, 3 = Mischievous, 4 = Mad) c n
(type) K
( Eyes = Double  ) p
(-- \\ / up    brows = 1  / \\ down brows = 0) c n
(type) K
( Mouth = Double ) p
(-- \\_/ happy mouth = 1  /-\\ sad mouth  = 0) c n
() p n
() N
(-------------------------------------------------------------------) c n
(-------- File read and write functions ----------------------------) N
(-------------------------------------------------------------------) N
() p n
(-- | readImages reads the contents of the input file and returns a list of images) c n
(--   \(represented as a list of Doubles\)) N
(readImages :: String -> [Image]) C n
(readImages input =) p n
(    ) S
(-- Cut input into lines, filter out empty lines, comments and image titles.) c n
(    ) p
(-- Cut the lines into words and convert them to numbers.) c n
(    ) p
(-- Convert the values to doubles and chunk up in separate images.) c n
(    ) p
(let) K
( commentsEtc l = not\(null l || head l == '#' || isAlpha \(head l\)\)) p n
(        processed = map read $ concatMap words $ tail $ filter commentsEtc $ lines input) N
(        \(width) S
(:) K
(height) p
(:) K
(images\) = processed ) p
(::) K
( ) p
([) K
(Double) p
(]) K n
(    ) p
(in) K
(  chunks \(round \(width * height\)\) \(map \(/31\) images\)) p n
() N
() N
(readAnswers :: String -> [Face]) C n
(readAnswers inputAnswers =) p n
(    map read $ filter \(\\line ) S
(->) K
( not \(isAlpha \(head line\)\)\) $ concatMap words $ removeComments \(lines inputAnswers\)) p n
(    ) S
(where) K
( removeComments xs =  filter \(\\line ) p
(->) K
( not \(null line || \(head line\) == '#'\)\) xs) p n
() N
(-- | writePGM converts a image \(or weight list\) to pgm-format and writes it to the given filename) c n
(writePGM :: FilePath -> [Double] -> IO \(\)) C n
(writePGM filename image = ) p
(let) K
( ints = map \(round . \(1000*\)\) image ) p
(::) K
( ) p
([) K
(Int) p
(]) K n
(                              posInts = map \(subtract $ minimum ints\) ints) p n
(                              pgm = concat $ intersperse ") S
( ) str
(" $ map show posInts) p n
(                              header = ") S
(P2\\n20 20\\n) str
(" ++ show \(maximum posInts\) ++ ") p
(\\n) str
(") p n
(                          ) S
(in) K
( writeFile filename \(header ++ pgm ++ ") p
(\\n) str
("\)) p n
() N
(-------------------------------------------------------------------) c n
(-------- Image functions ------------------------------------------) N
(-------------------------------------------------------------------) N
() p n
(-- | rotImgCorrect tries to rotate the image so that the eyes are up and the mouth is down.) c n
(rotImgCorrect :: Int -> Image -> Image) C n
(rotImgCorrect width img = ) p
(let) K
( images = take 4 \(iterate \(rotate90 width\) img\)) p n
(                              sumHalf = sum . filter \(>0.8\) . take \(\(width^2\) ) S
(`div`) K
( 2\)) p n
(                          ) S
(in) K
( head $ sortBy \(\\img1 img2 ) p
(->) K
( compare \(sumHalf img1\) \(sumHalf img2\)\) images) p n
() N
(-- | rotate90 rotates a square image 90 degrees counterclockwise.) c n
(rotate90 :: Int -> [a] -> [a]) C n
(rotate90 width img = rot \(chunks width img\) ) p
([]) K n
(    ) p
(where) K
( rot ) p
(::) K
( ) p
([[) K
(a) p
(]]) K
( ) p
(->) K
( ) p
([) K
(a) p
(]) K
( ) p
(->) K
( ) p
([) K
(a) p
(]) K n
(          rot im out = ) p
(if) K
( null $ head im) p n
(                           ) S
(then) K
( out) p n
(                           ) S
(else) K
( rot \(map tail im\) $ \(map head im\) ++ out) p n
() N
(Func.hs) (Page 1/3) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (Tuesday October 04, 2011) (2/8) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2) 3
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(-------------------------------------------------------------------) c n
(-------- Training -------------------------------------------------) N
(-------------------------------------------------------------------) N
() p n
(learnRate = 0.0001) N
() N
(-- | randomWeights returns a list of n random weights between 0 and 0.1) c n
(randomWeights :: Int -> [IO Weight]) C n
(randomWeights n | n < 1 = ) p
([]) K n
(                | otherwise = randomRIO \(0,0.1\) ) p
(:) K
( randomWeights \(n-1\)) p n
() N
(-- | updateWeights is used by batchTrain to modify the weights. This is basically the) c n
(--   the perceptron learning rule in action.) N
(updateWeights :: Double -> Double -> [Double] -> [Double] -> [Double]) C n
(updateWeights learnRate error inputs weights =) p n
(    zipWith \(\\x y ) S
(->) K
( y + learnRate * error * x\) inputs weights) p n
() N
() N
(-- | train takes one list of image and answer pairs to train on and one list to test on.) c n
(--   train returns trained weights) N
(train :: [\(Image,Double\)] -> [\(Image,Double\)] -> IO [Double]) C n
(train trainData tests = ) p
(do) K
( weights <- sequence $ randomWeights numPixels) p n
(                           trainHelper trainData tests weights \(0,) S
([]) K
(\)) p n
(                        ) S
(where) K
( numPixels = length $ fst $ head trainData) p n
() N
(-- | trainHelper takes one list of image and answer pairs to train on, one to test on, a list of weights) c n
(--   and a tuple. The tuple should consist of the best weights known yet, and how many of the images) N
(--   in the test list that was correctly classified with those weights. train returns trained) N
(trainHelper :: [\(Image,Double\)] -> [\(Image,Double\)] ->  [Weight] -> \(Int, [Double]\) -> IO [Double]) C n
(trainHelper xs tests weights best =) p n
(    ) S
(let) K
( \(newWeights, errs\) = batchTrain xs weights learnRate 0) p n
(        numCorTests = numCorrect tests newWeights) N
(        ) S
(--traceMsg = "corr " ++ \(show $ numCorTests\) ++ " errs " ++ \(show errs\) ++ " best " ++ \(show $ fst best\)) c n
(        current = \(numCorTests, newWeights\)) p n
(        newBest = ) S
(if) K
( fst best < fst current ) p
(then) K
( current ) p
(else) K
( best) p n
(    ) S
(in) K
( ) p
(if) K
( numCorTests >= length tests || errs < 7) p n
(          ) S
(then) K
( ) p
(do) K
( return $ snd newBest) p n
(          ) S
(else) K
( ) p
(do) K
( shuffled <- shuffle xs) p n
(                  trainHelper shuffled tests newWeights newBest) N
() N
(-- | batchTrain takes a list of image and answer pairs and the weights to be trained.) c n
(--   It returns the trained weights.) N
(batchTrain :: [\(Image,Double\)] -> [Double] -> Double -> Int -> \([Double],Int\)) C n
(batchTrain ) p
([]) K
( weights _ numErr = \(weights, numErr\) ) p
(-- nothing left to train on) c n
(batchTrain \(\(img,ans\)) p
(:) K
(xs\) weights learnRate numErr =) p n
(    ) S
(let) K
( error = ans - percieve img weights sigmoid) p n
(        newWeights = updateWeights learnRate error img weights) N
(    ) S
(in) K
( batchTrain xs newWeights learnRate \() p
(if) K
( abs error > 0.5 ) p
(then) K
( numErr+1 ) p
(else) K
( numErr\)) p n
() N
(-------------------------------------------------------------------) c n
(-------- Perception -----------------------------------------------) N
(-------------------------------------------------------------------) N
() p n
(sigmoid :: Double -> Double) C n
(sigmoid x = 1/\(1+\(exp \( 0-x \)\)\)) p n
() N
(step :: Double -> Double) C n
(step n = ) p
(if) K
( n > 0.5 ) p
(then) K
( 1 ) p
(else) K
( 0) p n
() N
(-- | percieveFace tries to classify a given image with a set of pretrained weights.) c n
(--   returns the face as an Int according to specs.) N
(percieveFace :: [Weight] -> [Weight] -> \(Double -> Double\) -> Image -> Face) C n
(percieveFace eyesWeigths mouthWeights actfn img =) p n
(    getFace \(percieve img eyesWeigths actfn\) \(percieve img mouthWeights actfn\)) N
() N
(-- | percieve takes a image, weights and and a activation function, and returns the neurons output) c n
(percieve :: Image -> [Weight] -> \(Double -> Double\) -> Double) C n
(percieve inputs weights actfn = actfn $ sum $ zipWith \(*\) inputs weights) p n
() N
() N
(-- | getEyesMouth returns the state of the eyes and mouth, given the face type.) c n
(getEyesMouth :: Face -> \(Eyes,Mouth\)) C n
(getEyesMouth 1 = \(0,1\)  ) p
(-- Happy) c n
(getEyesMouth 2 = \(0,0\) ) p
(-- Sad) c n
(getEyesMouth 3 = \(1,0\)  ) p
(-- Mischievous) c n
(getEyesMouth 4 = \(1,1\)   ) p
(-- Mad) c n
() p n
(-- | getFace takes the state of the eyes and mouth, and returns the facetype) c n
(getFace :: Eyes -> Mouth -> Face) C n
(getFace 0 1 = 1 ) p
(-- Happy) c n
(getFace 0 0 = 2 ) p
(-- Sad) c n
(getFace 1 0 = 3 ) p
(-- Mischievous) c n
(getFace 1 1 = 4 ) p
(-- Mad) c n
(getFace n m = -9000000 ) p
(-- should not happen) c n
() p n
(-------------------------------------------------------------------) c n
(-------- Testing --------------------------------------------------) N
(-------------------------------------------------------------------) N
() p n
(-- | kFold does kFold validation on the given input. It returns the accuracy as a value between 0.0 and 1.0.) c n
(kFold :: Int -> [\(Image, Double\)] -> IO Double) C n
(kFold k input = helper \(cycle input\) times 0) p n
(    ) S
(where) K
( times = length input ) p
(`div`) K
( k) p n
(          helper ) S
(::) K
( ) p
([) K
(\(Image, Double\)) p
(]) K
( ) p
(->) K
( Int ) p
(->) K
( Int ) p
(->) K
( IO Double) p n
(          helper xs 0 totCorr = return $ fromIntegral totCorr / \(fromIntegral $ length input\)) N
(          helper xs n totCorr =) N
(              ) S
(let) K
( \(tests, rest\) = splitAt k xs) p n
(                  trainData = take \(length input - k\) rest) N
(              ) S
(in) K
( ) p
(do) K
( weights <- train trainData tests) p n
(Func.hs) (Page 2/3) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (3/8) (Tuesday October 04, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3) 4
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                    ) p
(let) K
( newTot = totCorr + numCorrect tests weights) p n
(                    putStrLn $ ") S
(numCorrect ) str
(" ++ show newTot ++ ") p
( rounds left ) str
(" ++ show n) p n
(                    helper rest \(n-1\) newTot) N
() N
() N
(numCorrect :: [\(Image, Double\)] -> [Weight] -> Int) C n
(numCorrect xs weights = sum $ map \(\\\(img,ans\) ) p
(->) K
( fromEnum $ percieve img weights step == ans\) xs) p n
() N
(test :: [\(Image, Eyes\)] -> [\(Image, Mouth\)] -> [Weight] -> [Weight] -> [\(Face,Face,Bool\)] -> \([\(Face,Face,Bool\)], Int\)) C n
(test ) p
([]) K
( _ _ _ xs = \(xs,length $ \(filter \(\\\(_,_,tupple\) ) p
(->) K
( tupple\)\) xs\)) p n
(test \(\(image,eye\)) S
(:) K
(eyes\) \(\(_, mouth\)) p
(:) K
(mouths\) eyew mouthw xs =) p n
(    ) S
(let) K
( aj = \(percieve image eyew step\)) p n
(        moth = \(percieve image mouthw step\)) N
(        correct = aj == eye && moth == mouth) N
(        ) S
(in) K
( test eyes mouths eyew mouthw \(\(\(getFace aj moth\),\(getFace eye mouth\),correct\)) p
(:) K
(xs\)) p n
() N
(-------------------------------------------------------------------) c n
(-------- Helper functions -----------------------------------------) N
(-------------------------------------------------------------------) N
() p n
(-- | chunks splits the list xs into chunks with length n \(the last chunk may be shorter\).) c n
(chunks :: Int -> [a] -> [[a]]) C n
(chunks _ ) p
([]) K
( = ) p
([]) K n
(chunks n xs = y1 ) p
(:) K
( chunks n y2) p n
(    ) S
(where) K
( \(y1, y2\) = splitAt n xs) p n
() N
(----------------------------------------------------------) c n
(-- http://www.haskell.org/haskellwiki/Random_shuffle) N
(-- | Randomly shuffle a list) N
(--   /O\(N\)/) N
(shuffle :: [a] -> IO [a]) C n
(shuffle xs = ) p
(do) K
( ar <- newArray n xs) p n
(                forM ) S
([) K
(1..n) p
(]) K
( $ \\i ) p
(->) K
( ) p
(do) K n
(                    j <- randomRIO \(i,n\)) p n
(                    vi <- readArray ar i) N
(                    vj <- readArray ar j) N
(                    writeArray ar j vi) N
(                    return vj) N
(             ) S
(where) K n
(                 n = length xs) p n
(                 newArray ) S
(::) K
( Int ) p
(->) K
( ) p
([) K
(a) p
(]) K
( ) p
(->) K
( IO \(IOArray Int a\)) p n
(                 newArray n xs =  newListArray \(1,n\) xs) N
() N
() N
() N
({-) c n
(updateWeights :: Double -> Double -> [Double] -> [Double] -> [Double]) N
(updateWeights learnRate error inputs weights =) N
(    let h = sum $ zipWith \(*\) inputs weights) N
(    in zipWith \(\\x y -> y + learnRate * error * x * \(sigDeriv h\) \) inputs weights) N
() N
(sigDeriv :: Double -> Double) N
(sigDeriv x = exp x / \(\(1+exp x\)^2\)) N
(-}) N
() p n
(Func.hs) (Page 3/3) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (Tuesday October 04, 2011) (4/8) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 5
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(-----------------------------------------------------------------------------) c n
(--) N
(-- Module      :  Main) N
(-- Copyright   :) N
(-- License     :  AllRightsReserved) N
(--) N
(-- Maintainer  :) N
(-- Stability   :) N
(-- Portability :) N
(--) N
(-- |) N
(--) N
(-----------------------------------------------------------------------------) N
() p n
(module) K
( Main \() p n
() N
(    main) N
() N
(\) ) S
(where) K n
() p n
(import) K
( System.Environment \(getArgs, getProgName\)) p n
(import) K
( System.IO \(hClose, openFile, hGetContents\)) p n
(import) K
( Data.List \(\)) p n
(import) K
( System.Exit \(exitSuccess, exitFailure\)) p n
(import) K
( GHC.IO.IOMode \(IOMode\(..\)\)) p n
(import) K
( Func) p n
(       \(Image, Face, shuffle, train, getEyesMouth, chunks,) N
(        test, writePGM, rotImgCorrect, readImages, readAnswers, kFold\)) N
(import) K
( Control.Monad \(zipWithM_\)) p n
() N
(main = ) S
(do) K n
(    inputContents <- readFile ") p
(training.txt) str
(") p n
(    inputAnswers <- readFile ") S
(training-facit.txt) str
(") p n
(    ) S
(let) K
( images = map \(rotImgCorrect 20\) $ readImages inputContents) p n
(        answers = readAnswers inputAnswers) N
(        \(eyeAnswers, mouthAnswers\) = unzip \(map getEyesMouth answers\)) N
(        eyes = zip images eyeAnswers) N
(        mouth = zip images mouthAnswers) N
() N
(    shuffled <- shuffle \(zip eyes mouth\)) N
() N
(    ) S
(let) K
( \(shuffledEyes,shuffledMouth\) = unzip shuffled) p n
(        \(testEyes,trainEyes\) = splitAt 50 shuffledEyes) N
(        \(testMouth,trainMouth\) = splitAt 50 shuffledMouth) N
() N
() N
(    eyeweights2 <- train trainEyes testEyes) N
(    writePGM ") S
(eyew.pgm) str
(" eyeweights2) p n
(    writeFile ") S
(eye-weights) str
(" $ show eyeweights2) p n
(    mouthweights2 <- train trainMouth testMouth) N
(    writePGM ") S
(mouthw.pgm) str
(" mouthweights2) p n
(    writeFile ") S
(mouth-weights) str
(" $ show mouthweights2) p n
() N
() N
(    exitSuccess) N
() N
() N
() N
() N
() N
() N
({-) c n
(let \(|>\) = flip \($\)) N
(    procseesd = input |> lines |> filter commentsEtc |> tail |> concatMap words |> map read) N
(-}) N
(Train.hs) (Page 1/1) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (5/8) (Tuesday October 04, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 6
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(-----------------------------------------------------------------------------) c n
(--) N
(-- Module      :  Main) N
(-- Copyright   :) N
(-- License     :  AllRightsReserved) N
(--) N
(-- Maintainer  :) N
(-- Stability   :) N
(-- Portability :) N
(--) N
(-- |) N
(--) N
(-----------------------------------------------------------------------------) N
() p n
(module) K
( Main \() p n
() N
(    main) N
() N
(\) ) S
(where) K n
() p n
(import) K
( System.Environment \(getArgs, getProgName\)) p n
(import) K
( System.IO \(hClose, openFile, hGetContents\)) p n
(import) K
( Data.List \(\)) p n
(import) K
( System.Exit \(exitSuccess, exitFailure\)) p n
(import) K
( GHC.IO.IOMode \(IOMode\(..\)\)) p n
(import) K
( Func) p n
(       \(Image, Face, shuffle, train, getEyesMouth, chunks,) N
(        test, writePGM, rotImgCorrect, readImages, readAnswers, kFold\)) N
(import) K
( Control.Monad \(zipWithM_\)) p n
() N
(main = ) S
(do) K n
(    ) p
(let) K
( args =) p
([) K
(") p
(training.txt) str
(") p
(]) K n
(    ) p
(if) K
( null args) p n
(       ) S
(then) K
( ) p
(do) K
( putStrLn ") p
(No arguments given, exiting) str
(") p n
(               exitFailure) N
(       ) S
(else) K
( ) p
(do) K n
() p n
(    inputContents <- readFile $ head args) N
(    inputAnswers <- readFile ") S
(training-facit.txt) str
(") p n
(    ) S
(let) K
( images = map \(rotImgCorrect 20\) $ readImages inputContents) p n
(    ) S
(--Writing all images to file) c n
(    ) p
(--zipWithM_ \(\\image num -> writePGM \("rot" ++ \(show num\) ++ ".pgm"\);;;;;) c n
(    ) p
(-- ;;;;; $ \(rotImgCorrect image 20\)\) images [1..]) c n
(    ) p
(--writePGM "orig.pgm" $ images !! 10) c n
(    ) p
(--writePGM "rotated.pgm" $ rotImgRight \(images !! 10\) 20) c n
() p n
(    ) S
(let) K n
(        answers = readAnswers inputAnswers) p n
(        \(eyeAnswers, mouthAnswers\) = unzip \(map getEyesMouth answers\)) N
(        eyes = zip images eyeAnswers) N
(        mouth = zip images mouthAnswers) N
() N
(    shuffled <- shuffle \(zip eyes mouth\)) N
() N
(    ) S
(let) K
( \(shuffledEyes,shuffledMouth\) = unzip shuffled) p n
(        \(testEyes,trainEyes\) = splitAt 50 shuffledEyes) N
(        \(testMouth,trainMouth\) = splitAt 50 shuffledMouth) N
(--    permuEyes <- shuffle $ take 10000 $ cycle trainEyes) c n
(--    permuMouth <- shuffle $ take 10000 $ cycle trainMouth) N
({-) N
(    writePGM "img1.pgm" \(head images\)) N
(    eyeweights2 <- train trainEyes testEyes) N
(    writePGM "eyew.pgm" eyeweights2) N
(    writeFile "eye-weights" $ show eyeweights2) N
(    putStrLn $ show eyeweights2) N
(    mouthweights2 <- train trainMouth testMouth) N
(    writePGM "mouthw.pgm" mouthweights2) N
(    writeFile "mouth-weights" $ show mouthweights2) N
(-}) N
() p n
(    putStrLn ") S
(Eyes ) str
(") p n
() N
(    test <- kFold 25 eyes) N
(    putStrLn $ ") S
(Bertil ) str
(" ++ \(show test\)) p n
(    putStrLn ") S
(Mouth ) str
(") p n
(    kFold 25 mouth >>= \(putStrLn . show\)) N
() N
(    exitSuccess) N
() N
() N
() N
() N
() N
() N
({-) c n
(let \(|>\) = flip \($\)) N
(    procseesd = input |> lines |> filter commentsEtc |> tail |> concatMap words |> map read) N
(-}) N
(runkFold.hs) (Page 1/1) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (Tuesday October 04, 2011) (6/8) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 7
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(import) K
( System.Random \(randomRIO\)) p n
(import) K
( Data.Array.IO) p n
(import) K
( Control.Monad) p n
() N
() N
(updateWeights :: Double -> Double -> [Double] -> [Double] -> [Double]) C n
(updateWeights learnRate error inputs weights = ) p n
() S 8 T (zipWith \(\\x y ) S
(->) K
( x * y * learnRate * error\) inputs weights) p n
() N
() N
(step :: Double -> Bool) C n
(step n = ) p
(if) K
( n > 0 ) p
(then) K
( 1 ) p
(else) K
( 0) p n
() N
() N
(percieveFace :: Image -> Face) C n
(percieveFace img eyesWeigths mouthWeights actfn = ) p n
(    getFace \(percieve img eyesWeigths actfn\) \(percieve img mouthWeights actfn\)) N
() N
(-- ska percieve returnera true false, eller en Double?) c n
(percieve :: [Double] -> [Double] -> \(Double -> Bool\) -> Bool) C n
(percieve inputs weights actfn = actfn $ sum $ zipWith \(*\) inputs weights) p n
() N
(type) K
( Image = ) p
([) K
(Double) p
(]) K n
(type) S
( Face = Int ) p
(-- 1 = Happy, 2 = Sad, 3 = Mischievous, 4 = Mad) c n
(type) K
( Eyes = Bool) p n
(type) K
( Mouth = Bool) p n
() N
(-- getEyesMouth returns the state of the eyes and mouth, given the face type.) c n
(-- \\ / up    brows = True  / \\ down brows = False) N
(-- \\_/ happy mouth = True  /-\\ sad mouth  = False ) N
(getEyesMouth :: Face -> \(Eyes,Mouth\)) C n
(getEyesMouth 1 = \(False,True\)  ) p
(-- Happy) c n
(getEyesMouth 2 = \(False,False\) ) p
(-- Sad) c n
(getEyesMouth 3 = \(True,False\)  ) p
(-- Mischievous) c n
(getEyesMouth 4 = \(True,True\)   ) p
(-- Mad) c n
() p n
(getFace :: Eyes -> Mouth -> Face) C n
(getFace \(False,True\)  = 1 ) p
(-- Happy) c n
(getFace \(False,False\) = 2 ) p
(-- Sad) c n
(getFace \(True,False\)  = 3 ) p
(-- Mischievous) c n
(getFace \(True,True\)   = 4 ) p
(-- Mad) c n
() p n
(trainFace :: [\(Image,Face\)] -> ) C n
(trainFace learnRate \(img,face\)) p n
() N
(-- train takes a list of image and answer pairs to train on, the weights of the ) c n
(-- output node that should be trained, and the learning rate. It returns updated) N
(-- weights.) N
(train :: Double -> [\(Image,Bool\)] -> [Double] -> [Double]) C n
(train learnRate ) p
([]) K
( weights = weights ) p
(-- nothing left to train on) c n
(train learnRate \(\(img,ans\)) p
(:) K
(xs\) weights = ) p n
(    ) S
(if) K
( percieve img == ans) p n
(        ) S
(then) K
( train xs weights) p n
(        ) S
(else) K
( train xs \(update weights\)) p n
(    ) S
(where) K
( ) p n
(        percieve img = percieve img weights step) N
(        update weigths = updateWeights learnRate 1 img ws ) N
(-----------------------------------------------------) c n
(-- Flippin' images) N
(-----------------------------------------------------) N
() p n
(-- flipCW flips a  image clockwise) c n
(flipCW :: Image -> Int -> Image) C n
(flipCW img width = concat $ flip \(chunk img width\) ) p
([]) K n
(    ) p
(where) K
( flip ) p
(::) K
( ) p
([[) K
(Double) p
(]]) K
( ) p
(->) K
( ) p
([[) K
(Double) p
(]]) K n
(          flip ) p
([]) K
(  out = out ) p n
(          flip img out = flip \(map tail img\) \(map head img\) ) N
() N
(flip180 = reverse) N
() N
(-- Is it worth it, let me work it. I put my thing down, flip it and reverse it) c n
(flipCCW img width = flip180 . flipCW ) p n
() N
(-- http://www.haskell.org/haskellwiki/Random_shuffle) c n
(-- | Randomly shuffle a list) N
(--   /O\(N\)/) N
(shuffle :: [a] -> IO [a]) C n
(shuffle xs = ) p
(do) K
( ar <- newArray n xs) p n
(                forM ) S
([) K
(1..n) p
(]) K
( $ \\i ) p
(->) K
( ) p
(do) K n
(                    j <- randomRIO \(i,n\)) p n
(                    vi <- readArray ar i) N
(                    vj <- readArray ar j) N
(                    writeArray ar j vi) N
(                    return vj) N
(             ) S
(where) K n
(                 n = length xs) p n
(                 newArray ) S
(::) K
( Int ) p
(->) K
( ) p
([) K
(a) p
(]) K
( ) p
(->) K
( IO \(IOArray Int a\)) p n
(                 newArray n xs =  newListArray \(1,n\) xs) N
() N
() N
(---------------------------------------------) c n
(-- Trash:) N
(---------------------------------------------) N
() p n
() N
() N
(train2 :: Double -> [Image] -> [Bool] -> [Double] -> [Double]) C n
(train2 learnRate ) p
([]) K
( _ weights = weights ) p
(-- nothing left to train on) c n
(train2 learnRate \(img) p
(:) K
(is\) \(ans) p
(:) K
(as\) weights = ) p n
(test.hs) (Page 1/2) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (7/8) (Tuesday October 04, 2011) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2) 8
%%BeginPageSetup
/pagesave save def
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.154036 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( percieve img == ans) p n
(        ) S
(then) K
( train is as weights) p n
(        ) S
(else) K
( train is as \(update weights\)) p n
(    ) S
(where) K
( ) p n
(        percieve img = percieve img weights step) N
(        update weigths = updateWeights learnRate 1 img weights) N
() N
() N
() N
() N
({-) c n
(rndElem :: [a] -> IO a) N
(rndElem xs = do rand <- randomRIO \(0, length xs\)) N
(                return $ xs !! rand) N
(-}) N
(test.hs) (Page 2/2) (Oct 03, 11 23:15) title
border
grestore
(Printed by Bertil Nilsson) rhead
() (Tuesday October 04, 2011) (8/8) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
